import { useState, useEffect } from 'react';
import { collection, query, where, onSnapshot, addDoc, doc, updateDoc, deleteDoc, setDoc, serverTimestamp, getDocs, getDoc, db } from '../firebase';
import { v4 as uuidv4 } from 'uuid';
import FeedbackModal from './FeedbackModal';

const Matchmaker = ({ user, profile, onRoomJoined }) => {
  const [isSearching, setIsSearching] = useState(false);
  const [waitingUsers, setWaitingUsers] = useState([]);
  const [status, setStatus] = useState('idle'); // idle, searching, matched
  const [searchStartTime, setSearchStartTime] = useState(null);
  const [unsubscribe, setUnsubscribe] = useState(null);
  const [activeUsersCount, setActiveUsersCount] = useState(0);
  const [showFeedbackModal, setShowFeedbackModal] = useState(false);
  const [playMusic, setPlayMusic] = useState(() => localStorage.getItem("playMusic") !== "false");

  // Debug loggaus
  console.log("Matchmaker saanut props:", { user, profile });

  // Kuuntele odottavia k√§ytt√§ji√§ samasta ik√§ryhm√§st√§
  useEffect(() => {
    if (!profile?.ageGroup) return;

    const q = query(
      collection(db, 'waiting'),
      where('ageGroup', '==', profile.ageGroup)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const users = snapshot.docs
        .map(doc => ({
          id: doc.id,
          ...doc.data()
        }))
        .filter(waitingUser => waitingUser.uid !== user.uid); // Suodata oma uid pois
        
      setWaitingUsers(users);
      
      // ‚ùå POISTETTU AUTOMAATTINEN ROOM LUONTI
      // T√§m√§ rikkoi olemassa olevia pareja kun kolmas k√§ytt√§j√§ tuli mukaan
      // Nyt matchmaking tapahtuu vain startSearching funktiossa
    });

    return unsubscribe;
  }, [profile?.ageGroup, user.uid]);

  // Kuuntele aktiivisten k√§ytt√§jien m√§√§r√§√§
  useEffect(() => {
    const unsubscribeWaiting = onSnapshot(collection(db, 'waiting'), (snapshot) => {
      setActiveUsersCount(snapshot.size);
    });

    return unsubscribeWaiting;
  }, []);

    // Siivoa vanhat huoneet automaattisesti
  useEffect(() => {
    const cleanupOldRooms = async () => {
      try {
        const now = Date.now();
        const fiveMinutesAgo = now - (5 * 60 * 1000);
        
        // Hae vanhat huoneet
        const roomsQuery = query(collection(db, 'rooms'));
        const snapshot = await getDocs(roomsQuery);
        
        const deletePromises = [];
        
        snapshot.docs.forEach(roomDoc => {
          const data = roomDoc.data();
          const roomAge = now - (data.createdAt?.toDate?.()?.getTime() || 0);
          
          // Poista yli 5 minuuttia vanhat tai ep√§aktiiviset huoneet
          if (roomAge > fiveMinutesAgo || !data.isActive) {
            console.log("üóëÔ∏è Poistetaan vanha huone:", roomDoc.id);
            deletePromises.push(deleteDoc(doc(db, 'rooms', roomDoc.id)));
          }
        });
        
        if (deletePromises.length > 0) {
          await Promise.all(deletePromises);
          console.log(`‚úÖ Siivottiin ${deletePromises.length} vanhaa huonetta`);
        }
      } catch (error) {
        console.error("‚ùå Virhe huoneiden siivouksessa:", error);
      }
    };

    // Suorita siivous heti ja sitten 30 sekunnin v√§lein
    cleanupOldRooms();
    const interval = setInterval(cleanupOldRooms, 30000);
    
    return () => clearInterval(interval);
  }, []);

  // Cleanup musiikki kun komponentti poistuu
  useEffect(() => {
    return () => {
      // Pys√§yt√§ musiikki kun poistutaan Matchmaker-komponentista
      if (window.backgroundMusic) {
        window.backgroundMusic.pause();
        window.backgroundMusic.currentTime = 0;
        window.backgroundMusic = null;
      }
    };
  }, []);

  // Kuuntele localStorage-muutoksia (musiikki-asetukset)
  useEffect(() => {
    const handleStorageChange = () => {
      const musicSetting = localStorage.getItem("playMusic") !== "false";
      setPlayMusic(musicSetting);
    };

    // Kuuntele storage-tapahtumia (toinen v√§lilehti muuttaa asetusta)
    window.addEventListener('storage', handleStorageChange);
    
    // Kuuntele my√∂s custom-tapahtumaa samalla v√§lilehdell√§
    window.addEventListener('musicSettingChanged', handleStorageChange);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('musicSettingChanged', handleStorageChange);
    };
  }, []);

  // Aloita musiikki automaattisesti oletuksena
  useEffect(() => {
    if (playMusic) {
      // Varmista ettei musiikki jo soi
      if (!window.backgroundMusic) {
        const audio = new Audio('/meditation-relaxing-music-293922.mp3');
        audio.volume = 0.15;
        audio.loop = true;
        
        audio.play().catch(error => {
          console.log("Automaattinen musiikki estetty selaimessa:", error);
        });
        
        window.backgroundMusic = audio;
      }
    } else {
      // Pys√§yt√§ musiikki jos asetus on pois p√§√§lt√§
      if (window.backgroundMusic) {
        window.backgroundMusic.pause();
        window.backgroundMusic.currentTime = 0;
        window.backgroundMusic = null;
      }
    }
  }, [playMusic]); // Lis√§tty playMusic riippuvuudeksi

  // Kuuntele olemassa olevia huoneita joissa k√§ytt√§j√§ on mukana - korjattu versio
  useEffect(() => {
    if (!user?.uid || !isSearching) return;

    const q = query(
      collection(db, 'rooms'),
      where('userIds', 'array-contains', user.uid)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      // K√§sittele vain uusimmat muutokset t√§ss√§ sessiossa
      const changes = snapshot.docChanges().filter(change => change.type === 'added');
      
      changes.forEach(change => {
        const roomData = { id: change.doc.id, ...change.doc.data() };
        
        // Varmista ett√§ roomData on validia
        if (!roomData || !roomData.users || !Array.isArray(roomData.users)) {
          console.warn("‚ö†Ô∏è Virheellinen huonedata, ohitetaan:", roomData);
          return;
        }
        
        // Tarkista ett√§ huone on √§sken luotu (alle 30 sekuntia sitten)
        const roomAge = Date.now() - (roomData.createdAt?.toDate?.()?.getTime() || 0);
        const isNewRoom = roomAge < 30 * 1000; // 30 sekuntia
        
        if (roomData.isActive && isNewRoom) {
          console.log("üÜï L√∂ytyi uusi huone jossa olen mukana:", roomData.id);
          setIsSearching(false);
          setStatus('matched');
          onRoomJoined(change.doc.id, roomData);
        } else {
          console.log("‚è∞ Huone liian vanha tai ep√§aktiivinen, ohitetaan:", {
            age: Math.round(roomAge / 1000),
            isActive: roomData.isActive
          });
        }
      });
    }, (error) => {
      console.error("‚ùå Virhe huoneiden kuuntelussa:", error);
    });

    return unsubscribe;
  }, [user?.uid, isSearching, onRoomJoined]);

  // Luo chat-huone toisen k√§ytt√§j√§n kanssa
  const createChatRoom = async (otherUser) => {
    try {
      console.log("üèóÔ∏è Luodaan huone toisen k√§ytt√§j√§n kanssa:", otherUser);
      
      // Validoi otherUser
      if (!otherUser || !otherUser.id || !otherUser.name) {
        console.error("‚ùå Virheellinen otherUser:", otherUser);
        setStatus('error');
        return;
      }
      
      // Validoi oma profiili
      if (!profile?.displayName || !profile?.ageGroup) {
        console.error("‚ùå Oma profiili puutteellinen:", profile);
        setStatus('error');
        return;
      }
      
      setStatus('matched');
      
      // Luo uniikki huone-ID
      const roomId = uuidv4();
      
      // Luo huone Firestoreen
      const roomData = {
        id: roomId,
        userIds: [user.uid, otherUser.id], // K√§yt√§ otherUser.id eik√§ .uid
        users: [
          {
            uid: user.uid,
            displayName: profile.displayName,
            joinedAt: Date.now(),
            ready: false // Aluksi ei valmis
          },
          {
            uid: otherUser.id, // K√§yt√§ otherUser.id eik√§ .uid
            displayName: otherUser.name,
            joinedAt: Date.now(),
            ready: false // Aluksi ei valmis
          }
        ],
        ageGroup: profile.ageGroup,
        createdAt: serverTimestamp(),
        isActive: true,
        bothReady: false, // Molemmat eiv√§t viel√§ valmiita
        type: 'text' // vain tekstichat, ei videota
      };

      console.log("üíæ Tallennettava roomData:", roomData);

      const docRef = await addDoc(collection(db, 'rooms'), roomData);
      
      // K√§yt√§ todellista document ID:t√§
      const actualRoomId = docRef.id;
      const actualRoomData = { ...roomData, id: actualRoomId };
      
      console.log("‚úÖ Huone luotu ID:ll√§:", actualRoomId);
      
      // Merkitse itsemme valmiiksi huoneessa
      await updateDoc(doc(db, 'rooms', actualRoomId), {
        [`users.${roomData.users.findIndex(u => u.uid === user.uid)}.ready`]: true
      });
      
      // Poista molemmat k√§ytt√§j√§t waiting-listasta
      await deleteDoc(doc(db, 'waiting', user.uid));
      await deleteDoc(doc(db, 'waiting', otherUser.id));
      
      console.log("üéâ Siirtym√§ chat-huoneeseen");
      
      // Siirry chat-huoneeseen (odottamaan toista)
      onRoomJoined(actualRoomId, actualRoomData);
      
    } catch (error) {
      console.error('Virhe huoneen luonnissa:', error);
      setStatus('idle');
      setIsSearching(false);
    }
  };

  // Aloita k√§ytt√§jien etsint√§
  const startSearching = async () => {
    try {
      // Tarkista onko k√§ytt√§j√§ bannattu tai temp-bannattu
      const profileRef = doc(db, 'profiles', user.uid);
      const profileSnap = await getDoc(profileRef);
      
      if (profileSnap.exists()) {
        const profileData = profileSnap.data();
        
        // Tarkista ikuinen b√§nni
        if (profileData.banned) {
          alert('Et voi k√§ytt√§√§ palvelua. Syy: ' + (profileData.bannedReason || 'K√§ytt√∂ehtojen rikkominen'));
          return;
        }
        
        // Tarkista v√§liaikainen b√§nni
        if (profileData.temporaryBan?.active) {
          const bannedUntil = profileData.temporaryBan.bannedUntil.toDate ? 
            profileData.temporaryBan.bannedUntil.toDate() : 
            new Date(profileData.temporaryBan.bannedUntil);
          
          if (new Date() < bannedUntil) {
            // Temp-b√§nni on viel√§ voimassa
            const timeLeft = Math.ceil((bannedUntil - new Date()) / (1000 * 60 * 60)); // tunnit
            alert(`Et voi k√§ytt√§√§ palvelua viel√§ ${timeLeft} tuntia. Syy: ${profileData.temporaryBan.reason}`);
            return;
          } else {
            // Temp-b√§nni on vanhentunut, poista se
            console.log("üîì V√§liaikainen b√§nni vanhentunut, poistetaan");
            await updateDoc(profileRef, {
              'temporaryBan.active': false
            });
          }
        }
      }
      
      // Korjaa profiili jos ageGroup puuttuu
      let workingProfile = { ...profile };
      if (!workingProfile.ageGroup) {
        console.log("Korjataan profiili - lis√§t√§√§n ageGroup");
        
        // Laske ik√§ryhm√§ k√§ytt√§j√§n i√§n perusteella
        const calculateAgeGroup = (age) => {
          if (age >= 15 && age <= 17) return '15-17';
          if (age >= 18 && age <= 25) return '18-25';
          return '25+';
        };
        
        workingProfile.ageGroup = calculateAgeGroup(user.age);
        
        // P√§ivit√§ Firestore taustalla
        try {
          await setDoc(doc(db, 'profiles', user.uid), workingProfile);
        } catch (error) {
          console.warn("Firestore p√§ivitys ep√§onnistui:", error);
        }
      }

      // Varmista ett√§ profile on validi
      if (!workingProfile?.ageGroup || !workingProfile?.displayName) {
        console.error('Profile edelleen puutteellinen:', {
          profile: workingProfile,
          ageGroup: workingProfile?.ageGroup,
          displayName: workingProfile?.displayName,
          keys: Object.keys(workingProfile || {})
        });
        setStatus('Virhe: Profiili puutteellinen');
        return;
      }

      setIsSearching(true);
      setStatus('searching');
      setSearchStartTime(Date.now());
      
      // Tarkista onko jo odottavia k√§ytt√§ji√§
      if (waitingUsers.length > 0) {
        await createChatRoom(waitingUsers[0]);
        return;
      }
      
      // Lis√§√§ itsens√§ waiting-listaan k√§ytt√§en user.uid:t√§ ID:n√§
      const waitingRef = doc(db, 'waiting', user.uid);
      await setDoc(waitingRef, {
        id: user.uid, // K√§yt√§ 'id' kentt√§√§ yhteensopivuuden vuoksi
        uid: user.uid, // Pid√§ uid my√∂s
        name: workingProfile.displayName,
        ageGroup: workingProfile.ageGroup,
        timestamp: Date.now()
      });

      console.log("Lis√§tty waiting listaan:", user.uid, "nimi:", workingProfile.displayName, "ageGroup:", workingProfile.ageGroup);
      
      // Kuuntele waiting-listaa ja etsi match (yksinkertainen query ilman indeksi√§)
      const q = query(
        collection(db, 'waiting'),
        where('ageGroup', '==', workingProfile.ageGroup)
      );

      console.log("Aloitetaan kuuntelu waiting listaa...");
      
      const unsubscribe = onSnapshot(q, async (snapshot) => {
        console.log("onSnapshot triggered, l√∂ytyi dokumentteja:", snapshot.size);
        
        if (!snapshot.empty) {
          const waitingUsers = snapshot.docs
            .map(doc => ({
              id: doc.id,
              ...doc.data()
            }))
            .filter(waitingUser => waitingUser.uid !== user.uid); // Suodata oma uid pois
          
          console.log("Waiting k√§ytt√§j√§t (ilman omaa):", waitingUsers);
          
          // ‚úÖ KORJATTU: Tarkista ett√§ olemmeko edelleen etsim√§ss√§
          if (waitingUsers.length > 0 && isSearching) {
            // Ota ensimm√§inen k√§ytt√§j√§
            const otherUser = waitingUsers[0];
            console.log("L√∂ytyi match:", otherUser);
            
            setStatus('L√∂ytyi match! Luodaan chat...');
            unsubscribe(); // Lopeta kuuntelu
            
            await createChatRoom(otherUser);
          }
        }
      }, (error) => {
        console.error("Virhe waiting lista kuuntelussa:", error);
        setIsSearching(false);
        setStatus('idle');
      });
      
      // Tallenna unsubscribe funktio my√∂hemp√§√§ k√§ytt√∂√§ varten
      setUnsubscribe(() => unsubscribe);
      
    } catch (error) {
      console.error('Virhe etsinn√§n aloituksessa:', error);
      setIsSearching(false);
      setStatus('idle');
    }
  };

  // Lopeta etsint√§
  const stopSearching = async () => {
    try {
      setIsSearching(false);
      setStatus('idle');
      setSearchStartTime(null);
      
      // Lopeta listener jos on k√§ynniss√§
      if (unsubscribe) {
        unsubscribe();
        setUnsubscribe(null);
      }
      
      // Poista itsemme waiting-listasta
      await deleteDoc(doc(db, 'waiting', user.uid));
      
    } catch (error) {
      console.error('Virhe etsinn√§n lopetuksessa:', error);
    }
  };

  // Piilotus-toiminto poistettu k√§ytt√§j√§n pyynn√∂st√§

  // Laske etsint√§aika
  const getSearchDuration = () => {
    if (!searchStartTime) return 0;
    return Math.floor((Date.now() - searchStartTime) / 1000);
  };

  return (
    <div className="matchmaker-container">
      <div className="matchmaker-content">
        <h2>üîç Etsi chattikaveria</h2>
        
        {/* Aktiivisten k√§ytt√§jien n√§ytt√∂ */}
        <div className="user-stats">
          <p>üë• K√§ytt√§j√§t sivustolla: <strong>{activeUsersCount}</strong></p>
          <button 
            onClick={() => setShowFeedbackModal(true)} 
            className="feedback-link-btn"
          >
            üí¨ Anna palautetta
          </button>
        </div>
        
        {status === 'idle' && (
          <div className="search-controls">
            <button 
              onClick={startSearching}
              className="start-search-btn"
            >
              üöÄ ALOITA HAKU
            </button>
            
            <div className="info-box">
              <p>üí° <strong>N√§in se toimii:</strong></p>
              <ul>
                <li>üéØ Etsimme sinulle samanik√§ist√§ henkil√∂√§</li>
                <li>üí¨ Kun l√∂yd√§mme, chat alkaa automaattisesti</li>
                <li>‚ö° Prosessi kest√§√§ yleens√§ alle minuutin</li>
                <li>üîÑ Voit aloittaa uuden haun milloin tahansa</li>
              </ul>
            </div>
          </div>
        )}

        {status === 'searching' && (
          <div className="searching-status">
            <div className="spinner">üîÑ</div>
            <h3>Etsit√§√§n chattikaveria...</h3>
            <p>‚è±Ô∏è Aikaa kulunut: {getSearchDuration()} sekuntia</p>
            <p>üë• Odottavia k√§ytt√§ji√§ ik√§ryhm√§ss√§si: {waitingUsers.length}</p>
            
            <button 
              onClick={stopSearching}
              className="stop-search-btn"
            >
              ‚èπÔ∏è Lopeta haku
            </button>
            
            <div className="tips">
              <p>üí° <strong>Vinkki:</strong> Jos haku kest√§√§ kauan, kokeile hetken p√§√§st√§ uudelleen!</p>
            </div>
          </div>
        )}

        {status === 'matched' && (
          <div className="matched-status">
            <div className="success-icon">üéâ</div>
            <h3>L√∂ytyi chattikaveri!</h3>
            <p>Siirryt√§√§n chat-huoneeseen...</p>
          </div>
        )}
      </div>

      {/* Feedback Modal */}
      <FeedbackModal 
        isOpen={showFeedbackModal} 
        onClose={() => setShowFeedbackModal(false)} 
      />
    </div>
  );
};

export default Matchmaker;